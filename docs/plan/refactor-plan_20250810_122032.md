# UUID to Cognito Sub 完全移行計画書

作成日: 2025-08-10
作成者: Claude AI

## 1. 概要

### 1.1 目的と期待効果

**目的:**
- MonsteraプロジェクトにおけるUUID型からCognito Sub（string型）への完全移行
- 型の一貫性確保による実行時エラーの撲滅
- 技術的負債の解消

**期待効果:**
- 型不整合による実行時エラーの解消
- 開発効率の向上（型の混在による混乱の解消）
- 保守性の向上（一貫した型システム）
- Cognito認証システムとの完全な統合

### 1.2 スコープ

**対象範囲:**
- 全モデル（50以上）のID関連フィールド
- 全ハンドラー層の型処理
- 全サービス層のメソッドシグネチャ
- 全リポジトリ層のインターフェースと実装
- 全DTO層のフィールド定義
- 関連するテストコード

**対象外:**
- フロントエンド側の変更（既に対応済み）
- 認証ミドルウェア（既に対応済み）

## 2. 現状と改善後の比較

### 2.1 現状の問題点

```go
// 現状：型の混在
type User struct {
    ID string `gorm:"type:varchar(255)"` // ✅ 移行済み
}

type Expense struct {
    ID         uuid.UUID `gorm:"type:varchar(255)"` // ❌ UUID型
    UserID     string    `gorm:"type:varchar(255)"` // ✅ string型
    ApproverID *uuid.UUID                          // ❌ UUID型
}

// ハンドラーでの型不整合
userIDInterface, _ := c.Get("user_id") // string型
userID := userIDInterface.(uuid.UUID)   // ❌ パニック発生
```

### 2.2 改善後の構造

```go
// 改善後：全てstring型に統一
type User struct {
    ID string `gorm:"type:varchar(255)"` // Cognito Sub
}

type Expense struct {
    ID         string  `gorm:"type:varchar(255)"` // 統一
    UserID     string  `gorm:"type:varchar(255)"` // 統一
    ApproverID *string `gorm:"type:varchar(255)"` // 統一
}

// ハンドラーでの型一致
userIDInterface, _ := c.Get("user_id") // string型
userID := userIDInterface.(string)     // ✅ 型一致
```

### 2.3 メトリクスの改善予測

| メトリクス | 現状 | 改善後 | 改善率 |
|-----------|------|--------|--------|
| 型不整合エラー | 多数 | 0 | 100% |
| コード複雑度 | 高 | 低 | 40%減 |
| テストカバレッジ | 不明 | 80%以上 | - |
| 開発効率 | 低 | 高 | 50%向上 |

## 3. 実装計画

### 3.1 Phase 0: 準備フェーズ（2日間）

**目的:** 移行の基盤整備と影響範囲の最終確認

**タスク:**
1. 全プロジェクトのバックアップ作成
2. 移行用ブランチの作成（`feature/uuid-to-string-migration`）
3. 自動変換ツールの開発
   - uuid.UUIDからstringへの置換スクリプト
   - 型チェックツール
4. 影響を受けるファイルの最終リスト作成
5. ロールバック手順の文書化

**成果物:**
- バックアップ完了
- 移行ツール一式
- 影響ファイルリスト
- ロールバック手順書

### 3.2 Phase 1: モデル層の移行（3日間）

**目的:** 全モデルのID関連フィールドをstring型に統一

**タスク:**
1. **Day 1: 基本モデルの移行**
   - User関連モデル（完了確認）
   - Department, Project, Client
   - 基本的なマスターデータ

2. **Day 2: 業務モデルの移行**
   - Expense, WeeklyReport, DailyRecord
   - Leave, Attendance, WorkRecord
   - Notification, Session

3. **Day 3: 拡張モデルの移行**
   - Sales, Engineer, Profile関連
   - Archive, Audit関連
   - その他の残存モデル

**技術的詳細:**
```go
// 変換パターン
// Before
ID         uuid.UUID  `gorm:"type:varchar(255);primary_key"`
UserID     uuid.UUID  `gorm:"type:varchar(255)"`
CreatedBy  *uuid.UUID `gorm:"type:varchar(255)"`

// After
ID         string  `gorm:"type:varchar(255);primary_key"`
UserID     string  `gorm:"type:varchar(255)"`
CreatedBy  *string `gorm:"type:varchar(255)"`
```

**成果物:**
- 全モデルファイルの更新
- モデル層単体テストの通過

### 3.3 Phase 2: リポジトリ層の移行（4日間）

**目的:** リポジトリインターフェースと実装の型統一

**タスク:**
1. **Day 1: インターフェースの更新**
   - 全リポジトリインターフェースの型変更
   - BaseRepositoryの更新

2. **Day 2-3: 実装の更新**
   - UserRepository系の更新
   - 業務系リポジトリの更新
   - その他リポジトリの更新

3. **Day 4: リポジトリテスト修正**
   - 単体テストの型修正
   - モックの更新

**技術的詳細:**
```go
// インターフェース変更例
// Before
type UserRepository interface {
    GetByID(ctx context.Context, id uuid.UUID) (*model.User, error)
    FindByIDs(ctx context.Context, ids []uuid.UUID) ([]*model.User, error)
}

// After
type UserRepository interface {
    GetByID(ctx context.Context, id string) (*model.User, error)
    FindByIDs(ctx context.Context, ids []string) ([]*model.User, error)
}
```

**成果物:**
- 全リポジトリの更新完了
- リポジトリ層テストの通過

### 3.4 Phase 3: サービス層の移行（3日間）

**目的:** ビジネスロジック層の型統一

**タスク:**
1. **Day 1: 認証・ユーザー系サービス**
   - AuthService, UserService
   - SessionService, RoleService

2. **Day 2: 業務系サービス**
   - ExpenseService, WeeklyReportService
   - LeaveService, AttendanceService

3. **Day 3: その他サービスとテスト**
   - 残存サービスの更新
   - サービス層テストの修正

**成果物:**
- 全サービスの更新完了
- サービス層テストの通過

### 3.5 Phase 4: ハンドラー・DTO層の移行（3日間）

**目的:** プレゼンテーション層の型統一

**タスク:**
1. **Day 1: DTO定義の更新**
   - 全DTOのID関連フィールド更新
   - リクエスト/レスポンス型の更新

2. **Day 2: ハンドラーの更新**
   - ユーザーID取得処理の統一
   - パラメータ処理の更新

3. **Day 3: 統合テスト**
   - E2Eテストの実行と修正
   - APIテストの更新

**技術的詳細:**
```go
// ハンドラー更新例
// Before
userIDInterface, _ := c.Get("user_id")
userID := userIDInterface.(uuid.UUID) // パニック

// After
userIDInterface, _ := c.Get("user_id")
userID := userIDInterface.(string) // 安全
```

**成果物:**
- 全ハンドラー・DTOの更新完了
- APIテストの通過

### 3.6 Phase 5: クリーンアップと最適化（2日間）

**目的:** 移行の完成と最適化

**タスク:**
1. **Day 1: クリーンアップ**
   - uuid パッケージのインポート削除
   - 不要な型変換コードの削除
   - コードフォーマット実行

2. **Day 2: 最終確認**
   - 全テストスイートの実行
   - パフォーマンステスト
   - ドキュメント更新

**成果物:**
- クリーンなコードベース
- 全テストの通過
- 更新されたドキュメント

## 4. リスク管理

### 4.1 技術的リスク

| リスク | 影響度 | 発生確率 | 緩和策 |
|--------|--------|----------|--------|
| データベースの型不整合 | 高 | 中 | Phase 1で慎重に確認、マイグレーション作成 |
| 実行時パニック | 高 | 高 | 各フェーズでの段階的テスト |
| パフォーマンス劣化 | 中 | 低 | ベンチマークテストの実施 |
| 外部APIとの不整合 | 中 | 中 | APIクライアントの慎重な更新 |

### 4.2 スケジュールリスク

- **総工期:** 17日間（バッファ込み）
- **クリティカルパス:** Phase 1-2（モデル・リポジトリ層）
- **バッファ:** 各フェーズに20%のバッファを含む

### 4.3 緩和策

1. **段階的デプロイ**
   - 各フェーズ完了時点でのテスト環境デプロイ
   - 問題検出時の即座のロールバック

2. **並行開発対応**
   - 移行期間中の新規開発ガイドライン作成
   - 日次でのmainブランチからのマージ

3. **コミュニケーション**
   - 日次進捗レポート
   - 問題発生時の即座のエスカレーション

## 5. 移行戦略

### 5.1 既存コードとの共存

**Phase 1-2期間:**
- 一時的なアダプター層の実装
- 新旧両方の型をサポート

```go
// 一時的なアダプター
func adaptUUIDToString(id interface{}) string {
    switch v := id.(type) {
    case uuid.UUID:
        return v.String()
    case string:
        return v
    default:
        return ""
    }
}
```

### 5.2 データ移行

**不要:** データベース自体は既にvarchar(255)型のため、アプリケーション層のみの変更

### 5.3 後方互換性

- APIレスポンスは変更なし（既にstring型）
- 内部実装のみの変更のため、外部影響なし

## 6. テスト戦略

### 6.1 既存テストの活用

- 全ての既存テストを型変更に対応
- テストカバレッジの維持・向上

### 6.2 新規テストの追加

- 型変換境界のテスト
- 統合テストの拡充
- パフォーマンステスト

### 6.3 段階的検証

各フェーズ完了時:
1. ユニットテスト実行
2. 統合テスト実行
3. 手動テスト（重要機能）

## 7. ロールバック計画

### 7.1 Phase別ロールバック

- 各Phaseは独立してロールバック可能
- Gitブランチ戦略によるバージョン管理

### 7.2 緊急時対応

1. 問題検出時の即座の判断（30分以内）
2. ロールバック実行（1時間以内）
3. 原因分析と対策立案

## 8. 影響を受けるドキュメント

- [ ] API仕様書（内部実装のため更新不要）
- [x] 開発者ガイド
- [x] アーキテクチャドキュメント
- [x] コーディング規約
- [ ] ユーザーマニュアル（影響なし）

## 9. 成功基準

1. **技術的成功基準**
   - 全てのuuid.UUID型がstring型に移行完了
   - 全テストスイートの通過（カバレッジ80%以上）
   - パフォーマンス劣化なし（ベンチマーク±5%以内）

2. **ビジネス的成功基準**
   - ダウンタイムゼロ
   - ユーザー影響ゼロ
   - 移行後1週間の安定稼働

## 10. タイムライン

```
Week 1: Phase 0-1（準備とモデル層）
Week 2: Phase 2-3（リポジトリとサービス層）
Week 3: Phase 4-5（ハンドラー層とクリーンアップ）
```

## 11. 次のステップ

1. この計画書のレビューと承認
2. Phase 0の開始（移行ツール開発）
3. 日次進捗管理の開始

---

**注記:** この計画は現状分析に基づく推定です。実際の作業中に発見される問題により、調整が必要になる可能性があります。