# REFACTOR-PLAN フェーズ

# ユーザの入力
#$ARGUMENTS

## 目的
分析結果に基づき、安全で効果的なリファクタリング計画を策定する。

## 注意事項
- **Model: Opus** - リファクタリング設計には必ず**ultrathink**で深く検討すること
- 段階的な実装計画を立て、各段階でテスト可能にすること
- 既存機能への影響を最小限に抑えること

## 必要な入力ファイル
- `docs/analyze/refactor-analyze_{TIMESTAMP}.md` - 分析結果

## Serena活用ポイント
```bash
# 1. 既存パターンの確認
read_memory("implementation_patterns_*")
read_memory("coding_conventions")

# 2. 影響範囲の詳細確認
find_referencing_symbols("変更対象", depth=2)

# 3. テスト状況の確認
search_for_pattern("test.*変更対象")
```

## タスクに含まれるべきTODO
1. ユーザの指示を理解し、計画開始をコンソールで通知
2. 最新の分析結果を読み込み
3. **ultrathinkでリファクタリング戦略を深く検討**
4. リファクタリング目標の明確化
   - パフォーマンス目標
   - 保守性目標
   - 拡張性目標
5. 設計方針の決定
   - 適用するデザインパターン
   - アーキテクチャの変更点
   - インターフェースの改善
6. 段階的実装計画
   - Phase分割（各Phaseは独立してテスト可能）
   - 依存関係と実装順序
   - 各Phaseのリスク評価
7. 移行戦略
   - 既存コードとの共存方法
   - データ移行（必要な場合）
   - 後方互換性の維持
8. テスト戦略
   - 既存テストの活用
   - 新規テストの追加
   - パフォーマンステスト
9. ロールバック計画
10. 影響を受けるドキュメントのリスト
11. 計画を `docs/plan/refactor-plan_{TIMESTAMP}.md` に保存
12. 新しい設計パターンをSerenaメモリに記録
13. `afplay /System/Library/Sounds/Sosumi.aiff` で完了通知
14. 計画ファイル名をコンソール出力

## リファクタリング計画の構成
1. **概要**
   - 目的と期待効果
   - スコープ
2. **現状と改善後の比較**
   - Before/Afterの構造図
   - メトリクスの改善予測
3. **実装計画（細分化されたステップ）**
   
   **Phase 1: 準備と分析**
   - Step 1.1: 既存コードのバックアップ（5分）
     - 現在の状態をブランチに保存
     - タグ付けで復元ポイント作成
   - Step 1.2: 既存テストの実行と記録（10分）
     - 全テストを実行
     - ベースラインメトリクス記録
   - Step 1.3: 依存関係マップの作成（15分）
     - `find_referencing_symbols()`で依存関係調査
     - 影響範囲の図式化
   - Step 1.4: リファクタリング対象の優先順位付け（10分）
     - 影響度とリスクでスコアリング
     - 実装順序の決定
   
   **Phase 2: 構造の整理**
   - Step 2.1: インターフェース抽出（20分）
     - 公開APIの定義
     - 単体で動作確認
   - Step 2.2: 依存性注入の準備（15分）
     - コンストラクタ/セッターの追加
     - 既存動作を維持して確認
   - Step 2.3: 重複コードの特定（10分）
     - `search_for_pattern()`で類似パターン検索
     - 統合候補のリスト化
   - Step 2.4: 共通処理の抽出（各15分）
     - 1つずつユーティリティ関数化
     - 個別に単体テスト作成
   
   **Phase 3: モジュール分割**
   - Step 3.1: 大きなクラス/関数の分析（10分）
     - 責務の明確化
     - 分割ポイントの特定
   - Step 3.2: 単一責任の分離（各20分）
     - 1責務1モジュールに分割
     - 各モジュール単体でテスト
   - Step 3.3: レイヤー境界の明確化（15分）
     - プレゼンテーション層の分離
     - ビジネスロジック層の分離
     - データアクセス層の分離
   - Step 3.4: 各レイヤーの動作確認（各10分）
     - レイヤー単位でテスト実行
     - インターフェース確認
   
   **Phase 4: パフォーマンス最適化**
   - Step 4.1: ボトルネックの測定（15分）
     - プロファイリング実行
     - 改善ポイントの特定
   - Step 4.2: キャッシュ層の追加（20分）
     - Redis統合（必要な場合）
     - 単体での動作確認
   - Step 4.3: クエリ最適化（各10分）
     - N+1問題の解決
     - インデックス追加
     - 各変更後にベンチマーク
   - Step 4.4: 非同期処理の導入（各15分）
     - 長時間処理の非同期化
     - 個別に動作確認
   
   **Phase 5: コード品質向上**
   - Step 5.1: 命名規則の統一（各5分）
     - 変数名/関数名の改善
     - ファイル単位で実施
   - Step 5.2: 型定義の強化（15分）
     - TypeScript/Go型の追加
     - コンパイルエラーの解消
   - Step 5.3: エラーハンドリング改善（各10分）
     - try-catchの適切な配置
     - エラーメッセージの改善
   - Step 5.4: ログ出力の整理（10分）
     - 適切なログレベル設定
     - 構造化ログの導入
   
   **Phase 6: 検証と移行**
   - Step 6.1: 統合テスト実行（15分）
     - 全機能の動作確認
     - パフォーマンス比較
   - Step 6.2: 段階的切り替え（20分）
     - フィーチャーフラグ設定
     - A/Bテスト準備
   - Step 6.3: モニタリング設定（10分）
     - メトリクス収集
     - アラート設定
   - Step 6.4: ドキュメント更新（15分）
     - API仕様書更新
     - 内部設計書更新
   
4. **リスク管理**
   - 技術的リスク
   - スケジュールリスク
   - 緩和策

## 出力ファイル
- `docs/plan/refactor-plan_{TIMESTAMP}.md`

## 最終出力形式
### 計画策定完了の場合
status: SUCCESS
next: REFACTOR-IMPLEMENT
details: "リファクタリング計画策定完了。refactor-plan_{TIMESTAMP}.mdに詳細記録。実装フェーズへ移行。"

### リスクが高い場合
status: HIGH_RISK
next: USER_INPUT
details: "高リスクなリファクタリング。refactor-plan_{TIMESTAMP}.mdに詳細記録。承認が必要。"

### 段階的実装が必要な場合
status: PHASED_APPROACH
next: REFACTOR-IMPLEMENT
details: "段階的リファクタリング計画策定。refactor-plan_{TIMESTAMP}.mdに詳細記録。Phase 1から開始。"